
-- unescape a whole string, applying [unesc_digits] and
-- [unesc_letter] as many times as required.
-- Code from MetaLua project, file; lexer.lua.
-- Copyright (c) 2006, Fabien Fleutot <metalua@gmail.com>
-- released under the MIT Licence.
--
-- see: https://github.com/fab13n/metalua/blob/master/src/compiler/lexer.lua
local function unescape(s)

    -- Turn the digits of an escape sequence into the corresponding
    -- character, e.g. [unesc_digits("123") == string.char(123)].
    local function unesc_digits (backslashes, digits)
		if #backslashes%2==0 then
			-- Even number of backslashes, they escape each other, not the digits.
			-- Return them so that unesc_letter() can treaat them
			return backslashes..digits
		else
			-- Remove the odd backslash, which escapes the number sequence.
			-- The rest will be returned and parsed by unesc_letter()
			backslashes = backslashes :sub (1,-2)
		end
		local k, j, i = digits:reverse():byte(1, 3)
		local z = _G.string.byte "0"
		local code = (k or z) + 10*(j or z) + 100*(i or z) - 111*z
		if code > 255 then
			error ("Illegal escape sequence '\\"..digits..
				"' in string: ASCII codes must be in [0..255]")
		end
		return backslashes .. string.char (code)
   end

	-- Take a letter [x], and returns the character represented by the
	-- sequence ['\\'..x], e.g. [unesc_letter "n" == "\n"].
	local function unesc_letter(x)
		local t = {
			a = "\a", b = "\b", f = "\f",
			n = "\n", r = "\r", t = "\t", v = "\v",
			["\\"] = "\\", ["'"] = "'", ['"'] = '"', ["\n"] = "\n" }
		return t[x] or error([[Unknown escape sequence '\]]..x..[[']])
	end

	return s
		:gsub ("(\\+)([0-9][0-9]?[0-9]?)", unesc_digits)
		:gsub ("\\(%D)",unesc_letter)
end

----------------------------------------------------------------------
-- unescape a whole string. Including the enclosing quotes (if present)
-- generated by the format option %q.
-- @param s string to unescape, (reverse the string.format with %q option)
-- @return the unescaped string, with exterior double quotes " removed
function string.unescape(s)
    local quote = '"'
    s = unescape(s)
    if string.sub(s,1,1) == quote and string.sub(s, -1, -1) == quote then
        s = string.sub(s,2,-2)
    end
    return s
end

local function test()
    print("=======================================================================")
    print("  Testing 'string.unescape' function ")
    print("=======================================================================")
    local function test(a)
        print (type(a))
        a = tostring(a)
        print ("   original  :" .. a)
        a = string.format("%q", a)
        print ("   escaped   :" .. a)
        print ("   between   :" .. unescape(a))
        a = string.unescape(a)
        print ("   unescaped :" .. a)
    end

    test("hello")
    test(true)
    test()
    test(123.456)
    test({1,2,3})
    test("")
    test("hello\nworld\non\n2\nlines.")
    print("=======================================================================")
end

test()
